/*
  CUDA implementation of the NFFT.

  -----------

  Accelerating the Non-equispaced Fast Fourier Transform on Commodity Graphics Hardware.
  T.S. Sørensen, T. Schaeffter, K.Ø. Noe, M.S. Hansen. 
  IEEE Transactions on Medical Imaging 2008; 27(4):538-547.

  Real-time Reconstruction of Sensitivity Encoded Radial Magnetic Resonance Imaging Using a Graphics Processing Unit.
  T.S. Sørensen, D. Atkinson, T. Schaeffter, M.S. Hansen.
  IEEE Transactions on Medical Imaging 2009; 28(12):1974-1985. 
*/

#pragma once

#include "cuNDArray.h"
#include <thrust/device_vector.h>

template<class UINTd, class REALd, class REAL, class NDTYPE> class NFFT_plan
{

public: // Main interface
    
  enum NFFT_mode { NFFT_FORWARDS, NFFT_BACKWARDS };

  // Constructors
  NFFT_plan();
  NFFT_plan( UINTd matrix_size, UINTd matrix_size_os, UINTd fixed_dims, REAL W, int device = -1 );
  NFFT_plan( NFFT_plan<UINTd, REALd, REAL, NDTYPE> *plan );

  // Destructor
  ~NFFT_plan();

  // Replan 
  bool setup( UINTd matrix_size, UINTd matrix_size_os, UINTd fixed_dims, REAL W, int device = -1 );
    
  // Preproces trajectory
  bool preprocess( cuNDArray<REALd> *trajectory, bool forwards_only );
    
  // Execute NFFT
  bool compute( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image, cuNDArray<REAL> *weights, NFFT_mode mode );
  bool compute_iteration( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image, cuNDArray<REAL> *weights, NFFT_mode mode );

public: // Utilities
    
  // NFFT convolution
  bool convolve( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image, cuNDArray<REAL> *weights, NFFT_mode mode );
    
  // NFFT FFT
  bool FFT( cuNDArray<NDTYPE> *data, NFFT_mode mode, bool do_scale = true );

  // NFFT deapodization
  bool deapodize( cuNDArray<NDTYPE> *image );

private:   

  enum NFFT_components { NFFT_CONVOLUTION = 1, NFFT_H_CONVOLUTION = 2, NFFT_FFT = 4, NFFT_DEAPODIZATION = 8 };
  bool check_consistency( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image, cuNDArray<REAL> *weights, unsigned char components );

  // Shared barebones constructor
  bool barebones();

  // Clear plan
  void wipe( bool preprocess_only = true );
    
  // Compute beta control parameter for Kaiser-Bessel kernel
  bool compute_beta();

  // Compute deapodization filter
  bool compute_deapodization_filter();

  // A dedicated compute for each of the two NFFT directions
  bool compute_NFFT( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image );
  bool compute_NFFT_H( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image );

  // A dedicated convolution for each of the two NFFT directions
  bool convolve_NFFT( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image );
  bool convolve_NFFT_H( cuNDArray<NDTYPE> *samples, cuNDArray<NDTYPE> *image );
   
  // Internal utility to the NFFT_H convolution
  bool image_wrap( cuNDArray<NDTYPE> *source, cuNDArray<NDTYPE> *target/*, bool accumulate*/ );

private:
    
  UINTd matrix_size; 			  // Matrix size
  UINTd matrix_size_os;		  // Oversampled matrix size
  UINTd matrix_size_wrap;               // Wrap size at border

  UINTd fixed_dims;			  // "Boolean" denoting whether dimension is fixed (i.e. no gridding is neccessary).
  UINTd non_fixed_dims;			  // "Boolean" denoting whether dimension is non-fixed

  unsigned int d;			  // Dimensionality

  REAL W;				  // Kernel width (multipled by alpha for oversampling)
  REAL alpha;	          		  // Oversampling factor
  REAL beta;                            // Kaiser-Bessel convolution kernel control parameter

  unsigned int number_of_samples;       // Samples (per batch)
    
  int device;                  // Device id to run on

  cuNDArray<NDTYPE> *deapodization_filter;
    
  thrust::device_vector<REALd> *trajectory_positions;
  thrust::device_vector<unsigned int> *tuples_last;
  thrust::device_vector<unsigned int> *bucket_begin, *bucket_end;
    
  bool preprocessed_NFFT, preprocessed_NFFT_H;
  bool initialized;
};
