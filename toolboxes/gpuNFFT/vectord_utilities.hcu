#pragma once

#include "vectord.h"

#include <float.h>

//
// Get scalar limits of operation
//

template<class T> __inline__ __host__ __device__ T get_min();
template<class T> __inline__ __host__ __device__ T get_max();
template<class T> __inline__ __host__ __device__ T get_epsilon();

//
// Operations on real and real complex. (!!! _not_ a component-wise operation for complex numbers !!!)
//

template<class T> __inline__ __host__ __device__ T get_zero();
template<class T> __inline__ __host__ __device__ T get_one();
template<class T> __inline__ __host__ __device__ T get_half();
template<class T> __inline__ __host__ __device__ T reciprocal(const T&);
template<class S, class T> __inline__ __host__ __device__ T mul(const S&, const T&);

//
// Math operations on reals
//

template<class REAL> __inline__ __host__ __device__ REAL sincos( REAL, REAL );

//
// Individual member operations
//

template<class T, unsigned int D> __inline__ __host__ __device__ T get( const vectord<T,D> &vec, unsigned int dim ) { return vec.vec[dim]; }
template<class T, unsigned int D> __inline__ __host__ __device__ void set( vectord<T,D> &vec, unsigned int dim, T val ) { vec.vec[dim] = val; }

//
// Component-wise math operations
//

template<class T, unsigned int D> __inline__ __host__ __device__ vectord<T,D> abs( const vectord<T,D> &vec )
{
  vectord<T,D> res;
  for (unsigned int i=0; i<D; i++) {
    res.vec[i] = abs(vec.vec[i]);
  }
  return res;
}

template<class REAL, unsigned int D> __inline__ __host__ __device__ vectord<REAL,D> ceil( const vectord<REAL,D> &vec )
{
  vectord<REAL,D> res;
  for (unsigned int i=0; i<D; i++) {
    res.vec[i] = ceil(vec.vec[i]);
  }
  return res;
}

template<class REAL, unsigned int D> __inline__ __host__ __device__ vectord<REAL,D> floor( const vectord<REAL,D> &vec )
{
  vectord<REAL,D> res;
  for (unsigned int i=0; i<D; i++) {
    res.vec[i] = floor(vec.vec[i]);
  }
  return res;
}

//
// Vectorize a scalar value
//

template<class T, unsigned int D> __inline__ __host__ __device__ void to_vectord( vectord<T,D> &res, const T scalar )
{
  for (unsigned int i=0; i<D; i++) {
    res.vec[i] = scalar;
  }
} 

//
// Grid <-> index transformations
//

template<unsigned int D> __inline__ __host__ __device__ vectord<unsigned int,D> idx_to_co( unsigned int idx, const vectord<unsigned int,D> &dims )
{
  vectord<unsigned int,D> co;
  unsigned int idx_tmp = idx;
  for (unsigned int i=0; i<D; i++) {
    co.vec[i] = idx_tmp%dims.vec[i];
    idx_tmp -= co.vec[i];
    idx_tmp /= dims.vec[i];
  }
  return co;
} 

template<unsigned int D> __inline__ __host__ __device__ unsigned int co_to_idx( const vectord<unsigned int,D> &co, const vectord<unsigned int,D> &dims )
{
  unsigned int idx = 0;
  unsigned long block_size = 1;
  for (unsigned int i=0; i<D; i++) {
    idx += (block_size*co.vec[i]);
    block_size *= dims.vec[i];
  }
  return idx;
} 

template<unsigned int D> __inline__ __host__ __device__ unsigned int co_to_idx( const vectord<unsigned int,D> &co, const vectord<unsigned int,D> &dims, const vectord<unsigned int,D> &order )
{
  unsigned int idx = 0;
  unsigned long block_size = 1;
  for (unsigned int i=0; i<D; i++){
    idx += (block_size*co.d[order.vec[i]]);
    block_size *= dims.d[order.vec[i]];
  }
  return idx;
} 

template<unsigned int D> __inline__ __host__ __device__ uintd<D> counting_vec()
{
  uintd<D> res;
  for(unsigned int i=0; i<D; i++) {
    res.vec[i]=i;
  }
  return res;
}

//
// Reductions
//

template<class T, unsigned int D> __inline__ __host__ __device__ T prod( const vectord<T,D> &vec ){
  T res = get_one<T>();
  for (unsigned int i=0; i<D; i++){
    res *= vec.vec[i];
  }
  return res;
}

template<class T, unsigned int D> __inline__ __host__ __device__ T sum( const vectord<T,D> &vec ){
  T res = get_zero<T>();
  for (unsigned int i=0; i<D; i++){
    res += vec.vec[i];
  }
  return res;
}

template<class T, unsigned int D> __inline__ __host__ __device__ T dot( const vectord<T,D> &vec1, const vectord<T,D> &vec2 ){
  T res = get_zero<T>();
  for (unsigned int i=0; i<D; i++){
    res += (vec1.vec[i]*vec2.vec[i]);
  }
  return res;
}

template<class REAL, unsigned int D> __inline__ __host__ __device__ REAL norm( const vectord<REAL,D> &vec ){
  REAL res = get_zero<REAL>();
  for (unsigned int i=0; i<D; i++){
    res += (vec.vec[i]*vec.vec[i]);
  }
  return sqrt(res);
}

__inline__ __host__ __device__ float norm( const float r ){
  return abs(r);
}

__inline__ __host__ __device__ double norm( const double r ){
  return abs(r);
}

__inline__ __host__ __device__ float norm( const vectord<float,2> z ){
  return norm<float,2>(z);
}

__inline__ __host__ __device__ double norm( const vectord<double,2> z ){
  return norm<double,2>(z);
}

__inline__ __host__ __device__ float norm( const real_complex<float> z ){
  return norm<float,2>(z);
}

__inline__ __host__ __device__ float norm( const float_complex z ){
  return norm<float,2>(z);
}

__inline__ __host__ __device__ double norm( const real_complex<double> z ){
  return norm<double,2>(z);
}

__inline__ __host__ __device__ double norm( const double_complex z ){
  return norm<double,2>(z);
}

template<class REAL, unsigned int D> __inline__ __host__ __device__ REAL norm_squared( const vectord<REAL,D> &vec ){
  REAL res = get_zero<REAL>();
  for (unsigned int i=0; i<D; i++){
    res += (vec.vec[i]*vec.vec[i]);
  }
  return res;
}

__inline__ __host__ __device__ float norm_squared( const float r ){
  return r*r;
}

__inline__ __host__ __device__ double norm_squared( const double r ){
  return r*r;
}

__inline__ __host__ __device__ float norm_squared( const vectord<float,2> z ){
  return norm_squared<float,2>(z);
}

__inline__ __host__ __device__ double norm_squared( const vectord<double,2> z ){
  return norm_squared<double,2>(z);
}

//
// Type conversion
//

template<class T, unsigned int D> __inline__ __host__ __device__ void to_intd( vectord<int,D> &res, const vectord<T,D> &vec )
{
  for (unsigned int i=0; i<D; i++){
    res.vec[i] = (int) vec.vec[i];
  }
}

template<class T, unsigned int D> __inline__ __host__ __device__ void to_uintd( vectord<unsigned int,D> &res, const vectord<T,D> &vec )
{
  for (unsigned int i=0; i<D; i++){
    res.vec[i] = (unsigned int) vec.vec[i];
  }
}

template<class REAL, class T, unsigned int D> __inline__ __host__ __device__ void to_reald( vectord<REAL,D> &res, const vectord<T,D> &vec )
{
  for (unsigned int i=0; i<D; i++){
    res.vec[i] = (REAL) vec.vec[i];
  }
}

//
// Operations on complex types
//

template<class REAL> __inline__ __host__ __device__ vectord<REAL,2> real( const vectord<REAL,2> &z ){
  return z.vec[0];
}

template<class REAL> __inline__ __host__ __device__ vectord<REAL,2> imag( const vectord<REAL,2> &z ){
  return z.vec[1];
}

template<class REAL> __inline__ __host__ __device__ vectord<REAL,2> arg( const vectord<REAL,2> &z ){
  return atan2(imag(z), real(z));
}

template<class REAL> __inline__ __host__ __device__ vectord<REAL,2> conj( const vectord<REAL,2> &z ){
  vectord<REAL,2> res;
  res.vec[0] = z.vec[0]; 
  res.vec[1] = -z.vec[1];
  return res;
}

template<class REAL> __inline__ __host__ __device__ REAL conj( const REAL r ){ return r; } // required for template support of various types

//
// Explicit instantiations 
//

template<> __inline__ __host__ __device__ float get_zero<float>()
{
  return 0.0f;
}

template<> __inline__ __host__ __device__ double get_zero<double>()
{
  return 0.0;
}

template<> __inline__ __host__ __device__ int get_zero<int>()
{
  return 0;
}

template<> __inline__ __host__ __device__ unsigned int get_zero<unsigned int>()
{
  return 0;
}

template<> __inline__ __host__ __device__ vectord<float,2> get_zero<vectord<float,2> >()
{
  vectord<float,2> res;
  res.vec[0] = 0.0f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ real_complex<float> get_zero<real_complex<float> >()
{
  real_complex<float> res;
  res.vec[0] = 0.0f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ float_complex get_zero<float_complex >()
{
  float_complex res;
  res.vec[0] = 0.0f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ vectord<double,2> get_zero<vectord<double,2> >()
{
  vectord<double,2> res;
  res.vec[0] = 0.0;
  res.vec[1] = 0.0;
  return res;
}

template<> __inline__ __host__ __device__ real_complex<double> get_zero<real_complex<double> >()
{
  real_complex<double> res;
  res.vec[0] = 0.0;
  res.vec[1] = 0.0;
  return res;
}

template<> __inline__ __host__ __device__ double_complex get_zero<double_complex >()
{
  double_complex res;
  res.vec[0] = 0.0f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ float get_one<float>()
{
  return 1.0f;
}

template<> __inline__ __host__ __device__ double get_one<double>()
{
  return 1.0;
}

template<> __inline__ __host__ __device__ int get_one<int>()
{
  return 1;
}

template<> __inline__ __host__ __device__ unsigned int get_one<unsigned int>()
{
  return 1;
}

template<> __inline__ __host__ __device__ vectord<float,2> get_one<vectord<float,2> >()
{
  vectord<float,2> res;
  res.vec[0] = 1.0f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ real_complex<float> get_one<real_complex<float> >()
{
  real_complex<float> res;
  res.vec[0] = 1.0f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ vectord<double,2> get_one<vectord<double,2> >()
{
  vectord<double,2> res;
  res.vec[0] = 1.0;
  res.vec[1] = 0.0;
  return res;
}

template<> __inline__ __host__ __device__ real_complex<double> get_one<real_complex<double> >()
{
  real_complex<double> res;
  res.vec[0] = 1.0f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ float get_half<float>()
{
  return 0.5f;
}

template<> __inline__ __host__ __device__ double get_half<double>()
{
  return 0.5;
}

template<> __inline__ __host__ __device__ vectord<float,2> get_half<vectord<float,2> >()
{
  vectord<float,2> res;
  res.vec[0] = 0.5f;
  res.vec[1] = 0.0f;
  return res;
}

template<> __inline__ __host__ __device__ vectord<double,2> get_half<vectord<double,2> >()
{
  vectord<double,2> res;
  res.vec[0] = 0.5;
  res.vec[1] = 0.0;
  return res;
}

template<> __inline__ __host__ __device__ float reciprocal<float>( const float &real )
{
  return 1.0f/real;
}

template<> __inline__ __host__ __device__ double reciprocal<double>( const double &real )
{
  return 1.0/real;
}

template<> __inline__ __host__ __device__ vectord<float,2> reciprocal<vectord<float,2> >( const vectord<float,2> &z )
{
  vectord<float,2> res = conj(z);
  res *= (1.0f/norm_squared<float,2>(z));
  return res;
}

template<> __inline__ __host__ __device__ real_complex<float> reciprocal<real_complex<float> >( const real_complex<float> &z )
{
  real_complex<float> res = conj(z);
  res *= (1.0f/norm_squared<float,2>(z));
  return res;
}

template<> __inline__ __host__ __device__ float_complex reciprocal<float_complex >( const float_complex &z )
{
  float_complex res = conj(z);
  res *= (1.0f/norm_squared<float,2>(z));
  return res;
}

template<> __inline__ __host__ __device__ vectord<double,2> reciprocal<vectord<double,2> >( const vectord<double,2> &z )
{
  vectord<double,2> res = conj(z);
  res *= (1.0/norm_squared<double,2>(z));
  return res;
}

template<> __inline__ __host__ __device__ real_complex<double> reciprocal<real_complex<double> >( const real_complex<double> &z )
{
  real_complex<double> res = conj(z);
  res *= (1.0/norm_squared<double,2>(z));
  return res;
}

template<> __inline__ __host__ __device__ double_complex reciprocal<double_complex >( const double_complex &z )
{
  double_complex res = conj(z);
  res *= (1.0f/norm_squared<double,2>(z));
  return res;
}

template<> __inline__ __host__ __device__ float get_epsilon<float>()
{
  return FLT_EPSILON;
}

template<> __inline__ __host__ __device__ double get_epsilon<double>()
{
  return DBL_EPSILON;
}

template<> __inline__ __host__ __device__ float mul<float,float>( const float &a, const float &b )
{
  return a*b;
}

template<> __inline__ __host__ __device__ double mul<double,double>( const double &a, const double &b )
{
  return a*b;
}

template<> __inline__ __host__ __device__ vectord<float,2> mul<float, vectord<float,2> >( const float &a, const vectord<float,2> &b )
{
  vectord<float,2> res;
  res.vec[0] = a*b.vec[0];
  res.vec[1] = a*b.vec[1];
  return res;
}

template<> __inline__ __host__ __device__ real_complex<float> mul<float, real_complex<float> >( const float &a, const real_complex<float> &b )
{
  real_complex<float> res;
  res.vec[0] = a*b.vec[0];
  res.vec[1] = a*b.vec[1];
  return res;
}

template<> __inline__ __host__ __device__ float_complex mul<float, float_complex >( const float &a, const float_complex &b )
{
  float_complex res;
  res.vec[0] = a*b.vec[0];
  res.vec[1] = a*b.vec[1];
  return res;
}

template<> __inline__ __host__ __device__ vectord<double,2> mul<double, vectord<double,2> >( const double &a, const vectord<double,2> &b )
{
  vectord<double,2> res;
  res.vec[0] = a*b.vec[0];
  res.vec[1] = a*b.vec[1];
  return res;
}

template<> __inline__ __host__ __device__ real_complex<double> mul<double, real_complex<double> >( const double &a, const real_complex<double> &b )
{
  real_complex<double> res;
  res.vec[0] = a*b.vec[0];
  res.vec[1] = a*b.vec[1];
  return res;
}

template<> __inline__ __host__ __device__ double_complex mul<double, double_complex >( const double &a, const double_complex &b )
{
  double_complex res;
  res.vec[0] = a*b.vec[0];
  res.vec[1] = a*b.vec[1];
  return res;
}

template<> __inline__ __host__ __device__ vectord<float,2> mul<vectord<float,2>,vectord<float,2> >( const vectord<float,2> &a, const vectord<float,2> &b )
{
  vectord<float,2> res;
  res.vec[0] = a.vec[0]*b.vec[0]-a.vec[1]*b.vec[1];
  res.vec[1] = a.vec[0]*b.vec[1]+a.vec[1]*b.vec[0];
  return res;
}

template<> __inline__ __host__ __device__ real_complex<float> mul<real_complex<float>,real_complex<float> >( const real_complex<float> &a, const real_complex<float> &b )
{
  real_complex<float> res;
  res.vec[0] = a.vec[0]*b.vec[0]-a.vec[1]*b.vec[1];
  res.vec[1] = a.vec[0]*b.vec[1]+a.vec[1]*b.vec[0];
  return res;
}

template<> __inline__ __host__ __device__ float_complex mul<float_complex,float_complex >( const float_complex &a, const float_complex &b )
{
  float_complex res;
  res.vec[0] = a.vec[0]*b.vec[0]-a.vec[1]*b.vec[1];
  res.vec[1] = a.vec[0]*b.vec[1]+a.vec[1]*b.vec[0];
  return res;
}

template<> __inline__ __host__ __device__ vectord<double,2> mul<vectord<double,2>,vectord<double,2> >( const vectord<double,2> &a, const vectord<double,2> &b )
{
  vectord<double,2> res;
  res.vec[0] = a.vec[0]*b.vec[0]-a.vec[1]*b.vec[1];
  res.vec[1] = a.vec[0]*b.vec[1]+a.vec[1]*b.vec[0];
  return res;
}

template<> __inline__ __host__ __device__ real_complex<double> mul<real_complex<double>,real_complex<double> >( const real_complex<double> &a, const real_complex<double> &b )
{
  real_complex<double> res;
  res.vec[0] = a.vec[0]*b.vec[0]-a.vec[1]*b.vec[1];
  res.vec[1] = a.vec[0]*b.vec[1]+a.vec[1]*b.vec[0];
  return res;
}

template<> __inline__ __host__ __device__ double_complex mul<double_complex,double_complex >( const double_complex &a, const double_complex &b )
{
  double_complex res;
  res.vec[0] = a.vec[0]*b.vec[0]-a.vec[1]*b.vec[1];
  res.vec[1] = a.vec[0]*b.vec[1]+a.vec[1]*b.vec[0];
  return res;
}
