#pragma once

#include "cuNDArray.h"

#include <memory>
#include <vector>

//	
// cuNDArray utilities
//

//
// Utilities overwriting the input
//

// Clear
template<class T> 
void cuNDA_clear( cuNDArray<T> *data );

// Abs
template<class T> 
void cuNDA_abs( cuNDArray<T> *in_out );

// Reciprocal
template<class T> 
void cuNDA_reciprocal( cuNDArray<T> *in_out );

// Normalize
template<class REAL, class T> 
void cuNDA_normalize( cuNDArray<T> *in_out, REAL new_max );

// Normalize by RSS
template<class REAL, class T>  
bool cuNDA_rss_normalize( cuNDArray<T> *in_out, unsigned int dim );

// Scale - cublas wrapper
template<class A, class X> 
void cuNDA_scale( A a, X *x );

// .scale - x is overwritten
template<class A, class X> 
bool cuNDA_scale( cuNDArray<A> *a, cuNDArray<X> *x );

// 'axpy' - cublas wrapper
template<class A, class XY> 
bool cuNDA_axpy( A a, cuNDArray<XY> *x, cuNDArray<XY> *y );

// '.axpby' - .ax plus .by - y is overwritten
template<class A, class B, class XY> 
bool cuNDA_axpby( cuNDArray<A> *a, cuNDArray<XY> *x, cuNDArray<B> *b, cuNDArray<XY> *y );

//
// Utilities returning an auto_ptr to the resulting cuNDArray
//

// Norm
template<class REAL, class T> 
std::auto_ptr< cuNDArray<REAL> > cuNDA_norm( cuNDArray<T> *in );

// Norm squared
template<class REAL, class T>  
std::auto_ptr< cuNDArray<REAL> > cuNDA_norm_squared( cuNDArray<T> *in );

// RSS
template<class REAL, class T>  
std::auto_ptr< cuNDArray<REAL> > cuNDA_rss( cuNDArray<T> *in, unsigned int dim );

// Sum
template<class T>  
std::auto_ptr< cuNDArray<T> > cuNDA_sum( cuNDArray<T> *in, unsigned int dim );

//
// Utilities limited to UINTd instantiation
//

// Crop
template<class UINTd, class T> 
bool cuNDA_crop( UINTd offset, cuNDArray<T> *in, cuNDArray<T> *out );

// Expand with zero filling
template<class UINTd, class T>  
bool cuNDA_expand_with_zero_fill( cuNDArray<T> *in, cuNDArray<T> *out );

// Zero fill border (rectangular).
template<class UINTd, class T> 
bool cuNDA_zero_fill_border( UINTd matrix_size, cuNDArray<T> *image );

// Border fill (circular)
template<class UINTd, class REALd, class T>  
bool cuNDA_zero_fill_border( REALd radius, cuNDArray<T> *image );

//
// Conversion between vector<unsigned int> and UINTd
//

template<class UINTd>  
std::vector<unsigned int> cuNDA_toVec( UINTd dims );

template<class UINTd>  
bool cuNDA_fromVec( std::vector<unsigned int> from, UINTd &to );
