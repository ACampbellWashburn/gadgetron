#ifndef _NFFT_HCU_
#define _NFFT_HCU_

// This is our convolution device (defaults to zero but can be changed by the application)
extern unsigned int _convolution_device;

#include "preprocess.hpp"

#include <cuComplex.h>


/*
	--------------
	Host interface
	--------------
*/


/*
	Initialize NFFT
*/

template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ bool NFFT_initialize( PLAN<UINTd, FLOATd, TYPE> *plan );


/*
	Calculate NFFT
*/

template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ bool NFFT_compute( PLAN<UINTd, FLOATd, TYPE> *plan, cuFloatComplex *samplesDevPtr, bool oversampled_image, cuFloatComplex *imageDevPtr, bool densityCompensate );


/*
	Cleanup. Frees all Cuda memory allocated for the NFFT but does _not_ delete the 'PLAN' object.
*/

template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ bool NFFT_cleanup( PLAN<UINTd, FLOATd, TYPE> **plan  );


/*
	---------------
	Building blocks
	---------------
*/

// NFFT convolution
template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ bool NFFT_convolve( PLAN<UINTd, FLOATd, TYPE> *plan, cuFloatComplex *samplesDevPtr, cuFloatComplex *resultDevPtr );

// NFFT iteration convolution: image to samples
template< class UINTd, class FLOATd, char TYPE > 
__host__ bool NFFT_iteration_convolve_to_samples( mr_recon::NFFT_iteration_plan<UINTd, FLOATd, TYPE> *plan, cuFloatComplex *samplesDevPtr, cuFloatComplex *imageDevPtr );

// NFFT iteration convolution: samples to image
template< class UINTd, class FLOATd, char TYPE > 
__host__ bool NFFT_iteration_convolve_to_image( mr_recon::NFFT_iteration_plan<UINTd, FLOATd, TYPE> *plan, cuFloatComplex *samplesDevPtr, cuFloatComplex *imageDevPtr, bool accumulate = false );

// Density compensation
template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ bool density_compensate( PLAN<UINTd, FLOATd, TYPE> *plan, cuFloatComplex *out_samples_devPtr, const cuFloatComplex *in_samples_devPtr );

// Deapodize
template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ void deapodize( PLAN<UINTd, FLOATd, TYPE> *plan, bool oversampled_image, cuFloatComplex *imageDevPtr, bool ignore_fixed_dims = false );

// Estimate generic density compensation weights
template <class UINTd, class FLOATd> __host__
float* estimate_dcw( mr_recon::NFFT_iteration_plan<UINTd, FLOATd, 0> *plan, FLOATd *trajDevPtr );

// Compute trajectory
template <class UINTd, class FLOATd, char TYPE> __host__
FLOATd* compute_radial_sample_positions( unsigned int number_of_samples, UINTd matrix_size, UINTd matrix_size_os, float alpha, unsigned int samples_per_projection, unsigned int projections_per_frame, unsigned int angular_offset, unsigned int frames_per_rotation, float gc_factor, bool remove_os, bool normalize );

// Compute trajectory
template< class UINTd, class FLOATd, char TYPE > __host__ 
FLOATd* compute_radial_sample_positions( mr_recon::NFFT_iteration_plan<UINTd, FLOATd, TYPE> *plan, bool remove_oversampling = true, bool normalize = false );

// Get density compensation weights
template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ float* get_density_compensation_weights( PLAN<UINTd, FLOATd, TYPE> *plan );

// Get sample trajectories
template< class UINTd, class FLOATd, char TYPE, template< class, class, char > class PLAN > 
__host__ FLOATd* get_sample_trajectories( PLAN<UINTd, FLOATd, TYPE> *plan );

#endif
