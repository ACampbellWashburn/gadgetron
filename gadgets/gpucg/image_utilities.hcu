#ifndef _IMAGE_UTILS_
#define _IMAGE_UTILS_

#include <cuComplex.h>

/*	
	Image utilities
*/

// Image modulus
__host__ void 
image_modulus( cuFloatComplex *devPtr_in, float *devPtr_out, unsigned int number_of_elements, bool normalize, float normalize_scale = 1.0f );

// Image normalize
__host__ void 
image_normalize( unsigned int number_of_elements, float *devPtr );

// Image "normalize"
__host__ void 
normalize_max_length( unsigned int number_of_elements, cuFloatComplex *devPtr );

// Add two images
template< class T > __host__ void 
add_images( unsigned int num_elements, T *targetDevPtr, T *source1DevPtr,  T *source2DevPtr );

// Add multiple images
template< class T > __host__ void 
add_images( unsigned int num_elements, T *targetDevPtr, T *sourceDevPtr, unsigned int num_source_images );

// Subtract two images
template< class T > __host__ void 
subtract_images( unsigned int num_elements, T *targetDevPtr, T *source1DevPtr, T *source2DevPtr );

// Multiply two images
template< class T > __host__ void 
multiply_images( unsigned int num_elements, T *targetDevPtr, T *source1DevPtr,  T *source2DevPtr );

// Border fill (square)
template< class T, class UINTd > 
__host__ void cuda_border_fill_image( UINTd matrix_size, UINTd matrix_size_os, T value, T *imageDevPtr, unsigned int number_of_images = 1 );

// Border fill (circular shutter)
template< class T, class UINTd > 
__host__ void cuda_border_fill_image( UINTd matrix_size, float radius, T value, T *imageDevPtr, unsigned int number_of_images = 1 );

// Crop image
template< class T, class UINTd > 
__host__ void crop_image( UINTd out_matrix_size, UINTd in_matrix_size, T *out_ImageDevPtr, T *in_ImageDevPtr, unsigned int number_of_images = 1 );

// Multiply image with Gaussian
template< class T, class UINTd >
__host__ void image_multiply_gaussian( UINTd matrix_size, float sigma, T *imageDevPtr, unsigned int number_of_images = 1 );

// Clear image
template< class T > 
__host__ void clear_image( unsigned int num_elements, T val, T *imageDevPtr );

// Square image
template< class T > 
__host__ void square_image( unsigned int num_elements, T *imageDevPtr );

// Squareroot modulus image
__host__ void squareroot_modulus_image( unsigned int num_elements, float *imageDevPtr );

// Reciprocal image
__host__ void image_reciprocal( unsigned int num_elements, float *imageDevPtr );

// Copy image with zero filling
template< class UINTd > 
__host__ void image_copy_with_zero_fill( UINTd matrix_size, UINTd matrix_size_os, cuFloatComplex *image_DevPtr, cuFloatComplex *image_os_DevPtr, unsigned int number_of_images );

// Split complex image into two real images
__host__ void complex2real( unsigned int num_elements, cuFloatComplex *in, float *out_real, float *out_imag );

// Complex scale
__host__ void 
complex_image_scale( float scale, unsigned int number_of_elements, cuFloatComplex *devPtr );

void image_permute(cuFloatComplex* data_in, cuFloatComplex* data_out, uint4 dim, int num_shifts);

#endif
